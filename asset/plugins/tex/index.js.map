{"version":3,"file":"index.js","mappings":"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","sources":["webpack://TopWritePlugins.tex/webpack/runtime/load script","webpack://TopWritePlugins.tex/webpack/runtime/css loading","webpack://TopWritePlugins.tex/external window \"React\"","webpack://TopWritePlugins.tex/webpack/bootstrap","webpack://TopWritePlugins.tex/webpack/runtime/compat get default export","webpack://TopWritePlugins.tex/webpack/runtime/define property getters","webpack://TopWritePlugins.tex/webpack/runtime/ensure chunk","webpack://TopWritePlugins.tex/webpack/runtime/get javascript chunk filename","webpack://TopWritePlugins.tex/webpack/runtime/get mini-css chunk filename","webpack://TopWritePlugins.tex/webpack/runtime/global","webpack://TopWritePlugins.tex/webpack/runtime/hasOwnProperty shorthand","webpack://TopWritePlugins.tex/webpack/runtime/make namespace object","webpack://TopWritePlugins.tex/webpack/runtime/publicPath","webpack://TopWritePlugins.tex/webpack/runtime/jsonp chunk loading","webpack://TopWritePlugins.tex/external window \"TopWrite\"","webpack://TopWritePlugins.tex/../node_modules/micromark-util-character/index.js","webpack://TopWritePlugins.tex/../node_modules/micromark-util-character/lib/unicode-punctuation-regex.js","webpack://TopWritePlugins.tex/../node_modules/micromark-factory-space/index.js","webpack://TopWritePlugins.tex/../node_modules/micromark-extension-math/lib/math-flow.js","webpack://TopWritePlugins.tex/../node_modules/micromark-extension-math/lib/math-text.js","webpack://TopWritePlugins.tex/../node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","webpack://TopWritePlugins.tex/../node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js","webpack://TopWritePlugins.tex/../node_modules/mdast-util-to-markdown/lib/util/safe.js","webpack://TopWritePlugins.tex/../node_modules/mdast-util-math/index.js","webpack://TopWritePlugins.tex/../node_modules/longest-streak/index.js","webpack://TopWritePlugins.tex/../node_modules/remark-math/index.js","webpack://TopWritePlugins.tex/../node_modules/micromark-extension-math/lib/syntax.js","webpack://TopWritePlugins.tex/../node_modules/unist-util-is/index.js","webpack://TopWritePlugins.tex/../node_modules/unist-util-visit/node_modules/unist-util-visit-parents/index.js","webpack://TopWritePlugins.tex/../node_modules/unist-util-visit/index.js","webpack://TopWritePlugins.tex/./src/index.ts","webpack://TopWritePlugins.tex/./.topwrite/create-plugin.ts"],"sourcesContent":["var inProgress = {};\nvar dataWebpackPrefix = \"TopWritePlugins.tex:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","var createStylesheet = (chunkId, fullhref, resolve, reject) => {\n\tvar linkTag = document.createElement(\"link\");\n\n\tlinkTag.rel = \"stylesheet\";\n\tlinkTag.type = \"text/css\";\n\tvar onLinkComplete = (event) => {\n\t\t// avoid mem leaks.\n\t\tlinkTag.onerror = linkTag.onload = null;\n\t\tif (event.type === 'load') {\n\t\t\tresolve();\n\t\t} else {\n\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\tvar realHref = event && event.target && event.target.href || fullhref;\n\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + realHref + \")\");\n\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n\t\t\terr.type = errorType;\n\t\t\terr.request = realHref;\n\t\t\tlinkTag.parentNode.removeChild(linkTag)\n\t\t\treject(err);\n\t\t}\n\t}\n\tlinkTag.onerror = linkTag.onload = onLinkComplete;\n\tlinkTag.href = fullhref;\n\n\tdocument.head.appendChild(linkTag);\n\treturn linkTag;\n};\nvar findStylesheet = (href, fullhref) => {\n\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n\tfor(var i = 0; i < existingLinkTags.length; i++) {\n\t\tvar tag = existingLinkTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return tag;\n\t}\n\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n\tfor(var i = 0; i < existingStyleTags.length; i++) {\n\t\tvar tag = existingStyleTags[i];\n\t\tvar dataHref = tag.getAttribute(\"data-href\");\n\t\tif(dataHref === href || dataHref === fullhref) return tag;\n\t}\n};\nvar loadStylesheet = (chunkId) => {\n\treturn new Promise((resolve, reject) => {\n\t\tvar href = __webpack_require__.miniCssF(chunkId);\n\t\tvar fullhref = __webpack_require__.p + href;\n\t\tif(findStylesheet(href, fullhref)) return resolve();\n\t\tcreateStylesheet(chunkId, fullhref, resolve, reject);\n\t});\n}\n// object to store loaded CSS chunks\nvar installedCssChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.miniCss = (chunkId, promises) => {\n\tvar cssChunks = {\"664\":1};\n\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n\t\tpromises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(() => {\n\t\t\tinstalledCssChunks[chunkId] = 0;\n\t\t}, (e) => {\n\t\t\tdelete installedCssChunks[chunkId];\n\t\t\tthrow e;\n\t\t}));\n\t}\n};\n\n// no hmr","module.exports = window[\"React\"];","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \"-\" + {\"185\":\"1d0954\",\"664\":\"207448\"}[chunkId] + \".js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.css\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t179: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkTopWritePlugins_tex\"] = self[\"webpackChunkTopWritePlugins_tex\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"TopWrite\"];","/**\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {unicodePunctuationRegex} from './lib/unicode-punctuation-regex.js'\n/**\n * Check whether the character code represents an ASCII alpha (`a` through `z`,\n * case insensitive).\n *\n * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.\n *\n * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)\n * to U+005A (`Z`).\n *\n * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)\n * to U+007A (`z`).\n */\n\nexport const asciiAlpha = regexCheck(/[A-Za-z]/)\n/**\n * Check whether the character code represents an ASCII digit (`0` through `9`).\n *\n * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to\n * U+0039 (`9`).\n */\n\nexport const asciiDigit = regexCheck(/\\d/)\n/**\n * Check whether the character code represents an ASCII hex digit (`a` through\n * `f`, case insensitive, or `0` through `9`).\n *\n * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex\n * digit, or an ASCII lower hex digit.\n *\n * An **ASCII upper hex digit** is a character in the inclusive range U+0041\n * (`A`) to U+0046 (`F`).\n *\n * An **ASCII lower hex digit** is a character in the inclusive range U+0061\n * (`a`) to U+0066 (`f`).\n */\n\nexport const asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n/**\n * Check whether the character code represents an ASCII alphanumeric (`a`\n * through `z`, case insensitive, or `0` through `9`).\n *\n * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha\n * (see `asciiAlpha`).\n */\n\nexport const asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n/**\n * Check whether the character code represents ASCII punctuation.\n *\n * An **ASCII punctuation** is a character in the inclusive ranges U+0021\n * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT\n * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT\n * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).\n */\n\nexport const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n/**\n * Check whether the character code represents an ASCII atext.\n *\n * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in\n * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),\n * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F\n * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E\n * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE\n * (`{`) to U+007E TILDE (`~`).\n *\n * See:\n * **\\[RFC5322]**:\n * [Internet Message Format](https://tools.ietf.org/html/rfc5322).\n * P. Resnick.\n * IETF.\n */\n\nexport const asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n/**\n * Check whether a character code is an ASCII control character.\n *\n * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)\n * to U+001F (US), or U+007F (DEL).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < 32 || code === 127)\n  )\n}\n/**\n * Check whether a character code is a markdown line ending (see\n * `markdownLineEnding`) or markdown space (see `markdownSpace`).\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEndingOrSpace(code) {\n  return code !== null && (code < 0 || code === 32)\n}\n/**\n * Check whether a character code is a markdown line ending.\n *\n * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN\n * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).\n *\n * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE\n * RETURN (CR) are replaced by these virtual characters depending on whether\n * they occurred together.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownLineEnding(code) {\n  return code !== null && code < -2\n}\n/**\n * Check whether a character code is a markdown space.\n *\n * A **markdown space** is the concrete character U+0020 SPACE (SP) and the\n * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).\n *\n * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is\n * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL\n * SPACE (VS) characters, depending on the column at which the tab occurred.\n *\n * @param {Code} code\n * @returns {code is number}\n */\n\nexport function markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n/**\n * Check whether the character code represents Unicode whitespace.\n *\n * Note that this does handle micromark specific markdown whitespace characters.\n * See `markdownLineEndingOrSpace` to check that.\n *\n * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,\n * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),\n * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\\[UNICODE]**).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n\nexport const unicodeWhitespace = regexCheck(/\\s/)\n/**\n * Check whether the character code represents Unicode punctuation.\n *\n * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,\n * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`\n * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`\n * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII\n * punctuation (see `asciiPunctuation`).\n *\n * See:\n * **\\[UNICODE]**:\n * [The Unicode Standard](https://www.unicode.org/versions/).\n * Unicode Consortium.\n */\n// Size note: removing ASCII from the regex and using `asciiPunctuation` here\n// In fact adds to the bundle size.\n\nexport const unicodePunctuation = regexCheck(unicodePunctuationRegex)\n/**\n * Create a code check from a regex.\n *\n * @param {RegExp} regex\n * @returns {(code: Code) => code is number}\n */\n\nfunction regexCheck(regex) {\n  return check\n  /**\n   * Check whether a code matches the bound regex.\n   *\n   * @param {Code} code Character code\n   * @returns {code is number} Whether the character code matches the bound regex\n   */\n\n  function check(code) {\n    return code !== null && regex.test(String.fromCharCode(code))\n  }\n}\n","// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nexport const unicodePunctuationRegex =\n  /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n","/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownSpace} from 'micromark-util-character'\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {string} type\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n\nexport function factorySpace(effects, ok, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n/** @type {Construct} */\n\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return sizeOpen < 2\n      ? nok(code)\n      : factorySpace(effects, metaOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function metaOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 36) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('mathFlowFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          {\n            tokenize: tokenizeClosingFence,\n            partial: true\n          },\n          after,\n          initialSize\n            ? factorySpace(effects, contentStart, 'linePrefix', initialSize + 1)\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(effects, closingPrefixAfter, 'linePrefix', 4)\n    /** @type {State} */\n\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n  /** @type {State} */\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\nexport function mathText(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n\n    let size\n    /** @type {Token} */\n\n    let token\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return openingSequence(code)\n    }\n    /** @type {State} */\n\n    function openingSequence(code) {\n      if (code === 36) {\n        effects.consume(code)\n        sizeOpen++\n        return openingSequence\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code)\n      effects.exit('mathTextSequence')\n      return gap(code)\n    }\n    /** @type {State} */\n\n    function gap(code) {\n      if (code === null) {\n        return nok(code)\n      } // Closing fence?\n      // Could also be data.\n\n      if (code === 36) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return closingSequence(code)\n      } // Tabs don’t work, and virtual spaces don’t make sense.\n\n      if (code === 32) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return gap\n      }\n\n      if (markdownLineEnding(code)) {\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        return gap\n      } // Data.\n\n      effects.enter('mathTextData')\n      return data(code)\n    } // In math.\n\n    /** @type {State} */\n\n    function data(code) {\n      if (\n        code === null ||\n        code === 32 ||\n        code === 36 ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return gap(code)\n      }\n\n      effects.consume(code)\n      return data\n    } // Closing fence.\n\n    /** @type {State} */\n\n    function closingSequence(code) {\n      // More.\n      if (code === 36) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      } // Done!\n\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      } // More or less accents: mark as data.\n\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'mathTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 36 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Unsafe} pattern\n * @returns {RegExp}\n */\nexport function patternCompile(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @typedef {import('../types.js').Unsafe} Unsafe\n */\n\n/**\n * @param {Array.<string>} stack\n * @param {Unsafe} pattern\n * @returns {boolean}\n */\nexport function patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct, false)\n  )\n}\n\n/**\n * @param {Array.<string>} stack\n * @param {Unsafe['inConstruct']} list\n * @param {boolean} none\n * @returns {boolean}\n */\nfunction listInScope(stack, list, none) {\n  if (!list) {\n    return none\n  }\n\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  let index = -1\n\n  while (++index < list.length) {\n    if (stack.includes(list[index])) {\n      return true\n    }\n  }\n\n  return false\n}\n","/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array.<string>}} config\n * @returns {string}\n */\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array.<number>} */\n  const positions = []\n  /** @type {Array.<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array.<number>} */\n  const positions = []\n  /** @type {Array.<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function mathToMarkdown(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      single\n        ? {character: '$', inConstruct: ['mathFlowMeta', 'phrasing']}\n        : {\n            character: '$',\n            after: '\\\\$',\n            inConstruct: ['mathFlowMeta', 'phrasing']\n          },\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  function math(node, _, context) {\n    const raw = node.value || ''\n    const fence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    let value = fence\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += safe(context, node.meta, {\n        before: '$',\n        after: ' ',\n        encode: ['$']\n      })\n      subexit()\n    }\n\n    value += '\\n'\n\n    if (raw) {\n      value += raw + '\\n'\n    }\n\n    value += fence\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  function inlineMath(node) {\n    const value = node.value || ''\n    let size = 1\n    let pad = ''\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n    if (\n      /[^ \\r\\n]/.test(value) &&\n      (/[ \\r\\n$]/.test(value.charAt(0)) ||\n        /[ \\r\\n$]/.test(value.charAt(value.length - 1)))\n    ) {\n      pad = ' '\n    }\n\n    const sequence = '$'.repeat(size)\n    return sequence + pad + value + pad + sequence\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n","/**\n * Get the count of the longest repeating streak of `character` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} character\n *   Single character to look for.\n * @returns {number}\n *   Count of most frequent adjacent `character`s in `value`.\n */\nexport function longestStreak(value, character) {\n  const source = String(value)\n  let index = source.indexOf(character)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof character !== 'string' || character.length !== 1) {\n    throw new Error('Expected character')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + 1\n    index = source.indexOf(character, expected)\n  }\n\n  return max\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-math').ToOptions} Options\n *\n * @typedef {import('mdast-util-math')} DoNotTouchAsThisImportIncludesMathInTree\n */\n\nimport {math} from 'micromark-extension-math'\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\n\n/**\n * Plugin to support math.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root, Root>}\n */\nexport default function remarkMath(options = {}) {\n  const data = this.data()\n\n  add('micromarkExtensions', math(options))\n  add('fromMarkdownExtensions', mathFromMarkdown())\n  add('toMarkdownExtensions', mathToMarkdown(options))\n\n  /**\n   * @param {string} field\n   * @param {unknown} value\n   */\n  function add(field, value) {\n    const list = /** @type {unknown[]} */ (\n      // Other extensions\n      /* c8 ignore next 2 */\n      data[field] ? data[field] : (data[field] = [])\n    )\n\n    list.push(value)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('./math-text').Options} Options\n */\nimport {mathFlow} from './math-flow.js'\nimport {mathText} from './math-text.js'\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\n\nexport function math(options) {\n  return {\n    flow: {\n      [36]: mathFlow\n    },\n    text: {\n      [36]: mathText(options)\n    }\n  }\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n *\n * @typedef {string} Type\n * @typedef {Object<string, unknown>} Props\n *\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\n */\n\n/**\n * Check if a node passes a test\n *\n * @callback TestFunctionAnything\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean|void}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} X\n * @callback TestFunctionPredicate\n * @param {Node} node\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is X}\n */\n\n/**\n * @callback AssertAnything\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {boolean}\n */\n\n/**\n * Check if a node passes a certain node test\n *\n * @template {Node} Y\n * @callback AssertPredicate\n * @param {unknown} [node]\n * @param {number|null|undefined} [index]\n * @param {Parent|null|undefined} [parent]\n * @returns {node is Y}\n */\n\nexport const is =\n  /**\n   * Check if a node passes a test.\n   * When a `parent` node is known the `index` of node should also be given.\n   *\n   * @type {(\n   *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\n   *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * Check if a node passes a test.\n     * When a `parent` node is known the `index` of node should also be given.\n     *\n     * @param {unknown} [node] Node to check\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @param {number|null|undefined} [index] Position of `node` in `parent`\n     * @param {Parent|null|undefined} [parent] Parent of `node`\n     * @param {unknown} [context] Context object to invoke `test` with\n     * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\nexport const convert =\n  /**\n   * @type {(\n   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * Generate an assertion from a check.\n     * @param {Test} [test]\n     * When nullish, checks if `node` is a `Node`.\n     * When `string`, works like passing `function (node) {return node.type === test}`.\n     * When `function` checks if function passed the node is true.\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n     * When `array`, checks any one of the subtests pass.\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n/**\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {unknown[]} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Utility to assert each property in `test` is represented in `node`, and each\n * values are strictly equal.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s type\n * for said string.\n *\n * @param {Type} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Utility to convert a string into a function which checks a given node’s type\n * for said string.\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {Array.<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(...parameters) {\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call(this, ...parameters))\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('./complex-types').Action} Action\n * @typedef {import('./complex-types').Index} Index\n * @typedef {import('./complex-types').ActionTuple} ActionTuple\n * @typedef {import('./complex-types').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = true\n/**\n * Do not traverse this node’s children\n */\nexport const SKIP = 'skip'\n/**\n * Stop traversing immediately\n */\nexport const EXIT = false\n\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test node, optional\n * @param visitor Function to run for each node\n * @param reverse Visit the tree in reverse order, defaults to false\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types').Visitor<Node>} visitor\n     * @param {boolean} [reverse]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, null, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number?} index\n       * @param {Array.<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Object.<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = typeof node === 'object' && node !== null ? node : {}\n        /** @type {string|undefined} */\n        let name\n\n        if (typeof value.type === 'string') {\n          name =\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' +\n              color(value.type + (name ? '<' + name + '>' : '')) +\n              ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array.<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\n\nimport {visitParents, CONTINUE, SKIP, EXIT} from 'unist-util-visit-parents'\n\nexport {CONTINUE, SKIP, EXIT}\n\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test, optional\n * @param visitor Function to run for each node\n * @param reverse Fisit the tree in reverse, defaults to false\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types').Visitor} visitor\n     * @param {boolean} [reverse]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array.<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n","import createPlugin from '@@/create-plugin';\r\nimport { useEffect } from 'react';\r\nimport { markdown } from 'topwrite';\r\nimport math from 'remark-math';\r\nimport { Parent, visit } from 'unist-util-visit';\r\nimport { XBlock, XInline } from 'mdast';\r\nimport { InlineMath, Math } from 'mdast-util-math';\r\n\r\nconst Component = () => import('./components/tex');\r\n\r\nexport default createPlugin({\r\n    components: {\r\n        'block:math': Component,\r\n        'block:tex': Component,\r\n        'inline:$': Component,\r\n    },\r\n    activate() {\r\n        useEffect(() => {\r\n            markdown.use(math);\r\n            markdown.use(function() {\r\n                return function(tree) {\r\n\r\n                    const visitor = (node: InlineMath | Math, index: number, parent: Parent) => {\r\n                        if (index !== null && parent !== null) {\r\n                            if (node.type === 'math') {\r\n\r\n                                const child: XBlock = {\r\n                                    type: 'xBlock',\r\n                                    name: 'math',\r\n                                    value: node.value,\r\n                                    position: node.position\r\n                                };\r\n\r\n                                parent.children.splice(index, 1, child);\r\n                            } else if (node.type === 'inlineMath') {\r\n\r\n                                const child: XInline = {\r\n                                    type: 'xInline',\r\n                                    name: '$',\r\n                                    value: node.value,\r\n                                    position: node.position\r\n                                };\r\n\r\n                                parent.children.splice(index, 1, child);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    visit(tree, 'math', visitor);\r\n                    visit(tree, 'inlineMath', visitor);\r\n                };\r\n            });\r\n        }, []);\r\n\r\n    }\r\n});\r\n","import { ComponentsMap, GetComponentType, Plugin, PluginConfig, PluginMeta } from 'topwrite';\r\nimport { ComponentType, lazy } from 'react';\r\n\r\ndeclare const PLUGIN_NAME: string;\r\ndeclare const PLUGIN_META: PluginMeta | undefined;\r\ndeclare const SUPPORT_CONFIG: boolean;\r\ndeclare const SUPPORT_LANG: boolean;\r\n\r\ntype LazyType<T extends ComponentType<any>> = () => Promise<{ default: T }>;\r\n\r\ntype LazyCompType<index extends keyof ComponentsMap> = LazyType<GetComponentType<index>>;\r\n\r\nexport type LazyComponentsMap = {\r\n    [index in keyof ComponentsMap]?: LazyCompType<index> | [LazyCompType<index>, { priority?: number }]\r\n}\r\n\r\nexport interface PluginConstructorParams extends Omit<PluginConfig, 'name' | 'meta' | 'components' | 'config'> {\r\n    locales?: string[];\r\n    components?: LazyComponentsMap;\r\n}\r\n\r\nexport default function createPlugin({\r\n    components: lazyComponents,\r\n    localize,\r\n    locales,\r\n    ...others\r\n}: PluginConstructorParams) {\r\n    let config;\r\n    if (SUPPORT_CONFIG) {\r\n        config = require('../config.json');\r\n    }\r\n\r\n    if (SUPPORT_LANG) {\r\n        if (!localize && locales) {\r\n            localize = (locale) => {\r\n                if (locales.includes(locale)) {\r\n                    return import(`../src/lang/${locale}.json`);\r\n                }\r\n                return import(`../src/lang/${locales[0]}.json`);\r\n            };\r\n        }\r\n    }\r\n\r\n    let components: Partial<ComponentsMap> = {};\r\n    if (lazyComponents) {\r\n        for (const [name, component] of Object.entries(lazyComponents)) {\r\n            if (component) {\r\n                if (component instanceof Array) {\r\n                    components[name] = [lazy(component[0]), component[1]];\r\n                } else {\r\n                    components[name] = lazy(component);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return new Plugin({\r\n        name: PLUGIN_NAME,\r\n        meta: PLUGIN_META,\r\n        components,\r\n        localize,\r\n        config,\r\n        ...others\r\n    });\r\n}\r\n"],"names":["inProgress","dataWebpackPrefix","loadStylesheet","installedCssChunks","module","exports","window","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call","m","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","f","e","chunkId","Promise","all","keys","reduce","promises","u","miniCssF","g","globalThis","this","Function","obj","prop","prototype","hasOwnProperty","l","url","done","push","script","needAttach","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","r","Symbol","toStringTag","value","scriptUrl","importScripts","location","currentScript","Error","replace","p","resolve","reject","href","fullhref","existingLinkTags","dataHref","tag","rel","existingStyleTags","findStylesheet","linkTag","errorType","realHref","err","code","request","createStylesheet","miniCss","then","installedChunks","j","installedChunkData","promise","error","realSrc","message","name","webpackJsonpCallback","parentChunkLoadingFunction","data","chunkIds","moreModules","runtime","some","id","chunkLoadingGlobal","self","regexCheck","markdownLineEnding","markdownSpace","regex","test","String","fromCharCode","factorySpace","effects","ok","max","limit","Number","POSITIVE_INFINITY","size","enter","prefix","consume","exit","mathFlow","tokenize","nok","tail","events","initialSize","sliceSerialize","sizeOpen","sequenceOpen","metaOpen","openAfter","contentType","meta","interrupt","contentStart","after","attempt","nonLazyLine","tokenizeClosingFence","partial","contentContinue","closingSequence","closingSequenceEnd","concrete","lineStart","parser","lazy","now","line","mathText","options","single","singleDollarTextMath","token","openingSequence","gap","resolveMathText","previous","index","tailExitIndex","headEnterIndex","end","splice","patternCompile","pattern","_compiled","before","atBreak","RegExp","character","patternInScope","stack","listInScope","inConstruct","notInConstruct","list","none","includes","numerical","b","escapeBackslashes","expression","positions","results","whole","match","start","exec","slice","join","mathToMarkdown","inlineMath","peek","unsafe","handlers","math","node","_","context","raw","fence","repeat","Math","source","indexOf","expected","count","longestStreak","subexit","input","config","result","infos","Boolean","position","sort","charAt","encode","charCodeAt","toString","toUpperCase","safe","pad","sequence","remarkMath","add","field","flow","text","hName","hProperties","className","hChildren","mathFlowFenceMeta","buffer","resume","setData","mathFlowFence","getData","mathFlowValue","exitMathData","mathTextData","mathFromMarkdown","convert","check","castFactory","typeFactory","Array","isArray","tests","checks","any","parameters","anyFactory","propsFactory","visitParents","tree","visitor","reverse","is","step","factory","parents","tagName","visit","subresult","offset","grandparents","toResult","children","concat","parent","Component","components","lazyComponents","localize","locales","others","component","entries","Plugin","activate","useEffect","markdown","child"],"sourceRoot":""}